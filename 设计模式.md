[TOC]

# 设计模式

## 一、UML图简介

UML即统一建模语言，是oop的高度抽象建模表示。

### 1. 类图

在UML中类使用一个包含类名、属性、方法的长方形表示，他们之间用实现分隔。

- 类名：即类的名称，在命名空间中主要用于区别不同的类

- 属性：即类的性质、变量。表达方法为

  ```
  可见性 名称:类型 [ = 默认值]
  ```

  其中，可见性用符号表示：+(public)，-(private)，#(protected)

- 方法：指任一实例对象都可以调用的方法

  ```
  可见性 名称(参数列表) [:返回类型]
  ```

### 2. 关系

在`UML类图`中，常见的有以下几种关系: **泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)**

1. 泛化：由下至上的抽象，表现为继承

2. 实现：即实现

3. 聚合：表示两个实体对象的整体由部分构成的关系，当说A聚合到B上的时候，b消失了，a不一定消失

   比如 部门B和员工A 用一根空心菱形的实线描述

4. 组合：表示两个实体对象的整体由部分构成的关系，当说A组合到B上的时候，b消失了，a一定消失

   比如 公司B和部门A 用一根实心菱形的实线描述

5. 关联：表示两个对象存在自然的关系，用一根实线表示，如果带上箭头表示单方面知晓这个关系，如A指向B

   表示A知道B，但是B不知道A  比如人和身份证（双向），人与住的大街（单向），一般表现为成员变量

6. 依赖：表示一个对象在运行期间会用到另一个对象的关系，这个关系是临时性的，一般是方法的参数

   由一个虚线带箭头的线段表示，A指向B表示A调用B（B作为参数传入A）

## 二、设计原则

### 单一职责原则

单一职责原则是最简单的oop设计原则，它用于控制类的粒度大小。定义：

`Singel Responsibility Principle,SRP`：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变p化的原因。

### 开闭原则

开闭原则是oop可复用设计的第一块基石。定义：

`Open-Closed Principle,OCP`:一个软件实体应该对扩展开放，对修改关闭。即软件实体应该尽量在不修改原有代码的基础上进行扩展。

### 里氏代换原则

`Liskov Substitution Principle,LSP`：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有对象o1都代换成o2时，程序P行为没有变化，那么类型S是类型T的子类型

即是对父类与子类的关系有了定义，运用时应该尽量定义接口或者抽象类为父类，子类实例替换父类实例达到扩展的目的

### 依赖倒转原则

系统抽象化的具体实现，定义如下：

`Dependency Inversion Principle,DIP`：抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

依赖倒转原则要求程序对参数类型的定义是抽象类或者接口这样的高层次抽象，到时候仅仅需要扩展抽象层次代码并由新的子类替换父类实例达到扩展的目的。

- 具体类的对象需要通过依赖注入（Dependency Injection）的方式注入到其他对象中。依赖注入是指的一个对象要与另一个对象发生依赖关系的时候通过抽象来注入所以来的对象。常见的依赖注入方式有3种：
  - 构造注入：利用构造器初始化注入
  - 设值注入：通过setter方法来传入具体类对象
  - 接口注入：通过实现接口的业务方法来传入具体对象

### 接口隔离原则

​	`Interface Segregation Principle,ISP`：使用多个专门的接口而不是单一的总接口。

接口不应太大，承担太多责任，或出现冗余方法；也不应太小，会使得接口泛滥。一般而言，针对某类情况定制接口即可。

### 合成复用原则

合成复用原则又称组合/聚合复用原则

`Composite Reuse Principle,CRP`：尽量使用对象组合，而不是使用继承来达到复用的目的

### 迪米特法则

`Law of Demeter,LoD`：一个软件的实体应该尽可能的少与另一个软件实体产生联系

## 三、设计模式简介

设计模式是对一系列重复性高的问题的抽象解决方案，每个设计模式都具有模式名称、问题、解决方案、效果等要素。

设计模式一般分为三类（GoF）：

- 创建型（Creational）：主要描述如何创建对象								5种+简单工厂模式
- 结构型（Structural）：主要描述如何实现类或对象的组合               7种
- 行为型（Behavioral）：类或对象如何交互以及怎样分配职责          11种

## 四、创建型模式

创建型模式关注对象的创建过程，是一类最常用的设计模式。创建型模式将对象的创建和使用分离，在使用对象时无需关系对象创建细节，从而降低耦合度。每一个创建型模式都需要回答三个问题：

- 创建什么
- 由谁创建
- 创建时间

### 确保对象的唯一性——单例模式

#### 定义

单例模式（Singleton Pattern）：确保某一个类只有一个实例，该类自行实行实例化，并且向整个系统提供这个实例的创建型模式。

#### 目的

对于某些类来说，仅仅需要一个实例就够了（如：任务管理器），对于这部分类来说

1. 客户调用类的单个实例仅仅允许一个公共访问点，除了这个访问点无法通过其他途径访问该实例
2. 出于节省系统资源的角度来说，需要单例类
3. 这部分类的部分处于安全性的考虑，一定需要用单例类

#### 特征

1. 某个类仅仅有一个实例	-----单例
2. 必须自己创建这个实例    -----构造器用private修饰
3. 必须向整个系统提供这个实例    ------获得该实例的方法需要用public修饰

#### 简单的实现

```java
/**
 * <p>这是一个单例类</p>
 */
public class Singleton {
    private static Singleton singleton = null;

    private Singleton() {
    }

    public static Singleton getSingleton(){
        if (singleton == null){
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

#### 高并发时违反单例

在现实业务中，如果并发访问单例类有可能会出现以下问题：

A作为第一个访问的单例类，执行`if (singleton == null)`为`true`，于是开始初始化

同时，B也访问了`if (singleton == null)`，因为实例还在初始化，所以该判断也是`true`，于是B也开始初始化

因此很有可能出现多个实例从而违反了单例模式

#### 饿汉式和懒汉式单例模式

分析上述问题，我们不难发现问题的源头在于：**并发**执行到**初始化**部分，因此解决问题的方法就是从这两点入手

- 饿汉式单例模式

  因为时访问之后再进行的初始化，如果能够在访问之前就将实例初始化好的话------->恰好实例对象是静态的，可以利用类加载时初始化

  ```java
  /**
   * <p>这是一个懒汉式单例类</p>
   */
  public class Singleton {
      private static Singleton singleton = new Singleton();
  
      private Singleton() {
      }
  
      public static Singleton getSingleton(){
          return singleton;
      }
  }
  ```

- 懒汉式单例模式

  因为并发同时访问到初始化------->上锁

  ```java
  /**
   * <p>这是一个懒汉式单例类</p>
   */
  public class Singleton {
      private volatile static Singleton singleton = null;
  
      private Singleton() {
      }
  
      public static Singleton getSingleton() {
          if (singleton == null) {
              synchronized (Singleton.class) {
                  singleton = new Singleton();
              }
          }
          return singleton;
      }
  }
  ```

- 二者优劣

  懒汉式：懒加载运用了锁，将会使系统性能受到影响

  饿汉式：无需考虑并发问题，但是系统加载过程很长，且占用资源

#### IoDH——巧妙结合两者

现在来考虑怎么样能够将两者的有点利用起来：要点就是要**加载的时候完成初始化**且**单例类不调用获得实例方法的时候不去加载**，二者在一个类的情况下是矛盾的，因此就不只有一个类，我们引入一个静态内部类

```java
/**
 * <p>这是IoDH</p>
 */
public class Singleton {
    private Singleton singleton = null;

    private Singleton() {
    }

    private static class SingletonInner {
        private static final Singleton instance = new Singleton();
    }

    public static Singleton getSingleton() {
        return SingletonInner.instance;
    }
}
```

#### 优点、缺点

- 优点
  1. 单例模式提供了对唯一实例的受控访问
  2. 节约资源
  3. 基于单例模式可以写出获得指定个数的多例模式
- 缺点
  1. 没有抽象层，几乎不能扩展
  2. 职责过重：又有业务方法，又有创建方法，违背单一职责
  3. 长时间未使用时可能会被GC回收，再一次建立的单例状态可能不同

### 集中式工厂的实现——简单工厂模式

#### 定义

`Simple Factory Pattern`：定义一个工厂类，它可以根据参数的不同返回不同的实例，被创建的实例通常拥有共同的父类。因为这个创建实例方法是静态的，所以简单工厂模式也叫做静态工厂方法(`Static Factory Method`)模式。

#### 目的

**分离对象的创建和使用**、在使用对象的时候无须关心其创建细节（不会在各个类里面看到某个类创建的数据和代码  -->他们都被移动到工厂类和配置文件中去了）。

#### 创建对象和使用对象

与一个对象相关的职责通常有3类：对象本身的职责（处理内部数据）、创建对象的职责（创建其他对象）、使用对象的职责（使用其他对象）。一般来说，创建对象有以下四种方式

1. 通过`new`关键字创建对象
2. 通过反射机制创建对象
3. 通过`clone()`方法创建对象
4. 通过工厂类创建对象

如果一个类不仅负责创建对象，也负责使用对象它的职责就太重了，比如

```java
public class A{
    private B b;
    
    public A(){
        b = new B();
    }
    
    public void execute(){
        // ...
        b.doSome();
        // ...
    }
}
```

A既负责创建b，也负责使用b，如果某个时候想把B换成类似的C，将不得不修改A里面的源码，违反开闭原则。

#### 特征

1. 一个工厂类根据传入参数负责创建所有产品：有一个根据参数创建实例的方法
2. 多个产品的共性抽象出的公共产品类
3. 每个具体产品实现公共产品。

#### 简单的实现

```java
/**
 * <p>公共产品类</p>
 */
public abstract class Product {
    public void doSome() {
        System.out.println("公共业务方法");
    }

    public abstract void doIn();//具体产品业务方法
}
```

```java
/**
 * <p>具体产品类A</p>
 */
public class ProductA extends Product {
    @Override
    public void doIn() {
        System.out.println("A做了它该做的事情");
    }
}
```

```java
/**
 * <p>具体产品类B</p>
 */
public class ProductB extends Product {
    @Override
    public void doIn() {
        System.out.println("B做了它该做的事情");
    }
}
```

```java
/**
 * <p>工厂类</p>
 */
public class Factory {
    private static Product product = null;

    public static Product getProduct(String type) {
        if (type == "A") {
            product = new ProductA();
        }
        if (type == "B") {
            product = new ProductB();
        }
        return product;
    }
}
```

```java
/**
 * <p>客户端代码</p>
 */
public class Test {
    public static void main(String[] args) {
        Product a = Factory.getProduct("A");
        if (a == null){
            return;
        }
        a.doIn();
    }
}
```

#### 不违背开闭原则的修改getProduct()里面的参数

如果需要进入原代码修改参数（更改生产的对象）的话，将会违背开闭原则。因此关于参数的控制，我们需要在外部的配置文件中控制。

#### 优点、缺点

- 优点：

  1. 分离了对象的创建和消费的过程
  2. 减少使用者的记忆量，配合配置文件的使用加大灵活性

- 缺点：
  1. 工厂类集中了所有创建逻辑细节，是创建的中心，职责过重，一旦出现问题会影响整个系统
  2. 引入工厂类增加了系统复杂度和理解难度
  3. 简单工厂模式因为使用了静态方法，工厂角色无法形成基于继承的等级结构，只能修改源代码
  4. **系统扩展困难，一旦增加了新的产品只能通过修改工厂类源代码，当产品较多时将会造成维护困难**

### 多态工厂的实现——工厂方法模式

#### 定义

`Factory Method Pattern`：定义一个用于创建对象的接口，让其子类决定将哪一个类实例化。工厂模式又称虚拟构造器模式(`Virtual Constructor Pattern`)和多态工厂模式(`Polymorphic`)

#### 目的

简单工厂模式虽然很好的将对象的创建和消费进行了分离，但依然存在新增产品违背开闭原则和初始化创建细节过重的问题，因此为了解决这些问题引入了工厂方法模式。

#### 特征

1. 工厂方法模式是简单工厂方法模式的改进——简单工厂模式为基础
2. 不违背开闭原则新增产生产品的工厂方法代码——所有工厂类需要一个共同的抽象接口：抽象工厂类
3. 多个工厂类生产多个产品——最好的对应方式当然是一一对应
4. 各种创建细节可以在具体的工厂类中处理——在工厂类中处理初始化逻辑和创建细节

#### 简单的实现

```java
//抽象工厂类
public interface Factory {Product createProduct();}
```

```java
//抽象产品类
public interface Product {void doSome();}
```

```java
// 狄拉克工厂类
public class DiracFactory implements Factory {
    @Override
    public Product createProduct() {
        return new Dirac();
    }
}
```

```java
// 棉花糖工厂类
public class MarshmallowFactory implements Factory {
    @Override
    public Product createProduct() {
        // 初始化过程
        return new Marshmallow();
    }
}
```

```java
/**
 * 狄拉克产品
 */
public class Dirac implements Product {

    private final String name = "Dirac";
    private final String symbol = "<|>";

    @Override
    public void doSome() {
        System.out.println(name + "符号就是" + symbol);
    }
}
```

```java
/**
 *  棉花糖产品
 */
public class Marshmallow implements Product{
    @Override
    public void doSome() {
        System.out.println("好吃！");
    }
}
```

```java
/**
 * 客户端
 */
public class Client {
    public static void main(String[] args) {
        Factory factory = new DiracFactory();
        Factory factory2 = new MarshmallowFactory();
        Product product = factory.createProduct();
        product.doSome();					// Dirac符号就是<|>
        product = factory2.createProduct();
        product.doSome();					// 好吃！
    }
}
```

#### 使用反射来创建具体工厂类

仔细思考上面的例子，发现在客户端中不可能全部工厂类都创建一遍，并且不知道到底需要用哪一个，到时候进行修改的时候势必会修改源代码，违背开闭原则，此时使用反射+配置文件来解决这个问题

```yaml
# 到时候读取本配置文件即可
factoryName: DiracFactory
```

```java
// 客户端类
// ... 代码
String factoryName = yamlUtils.getfactoryName;// 这里就是从配置文件里面获取的类名
Class factoryClass = Class.forName("factoryPattern."+factoryName);	// 前面的是包名
Factory o = (Factory)factoryClass.getDeclaredConstructor().newInstance();
Product product = o.createProduct();
product.doSome();
```

#### 优点、缺点

- 优点：
  1. 可以任意不违背开闭原则的情况下创建新的工厂和对应产品
  2. 创建过程完全对客户隐藏，都被封装在工厂类里面了

- 缺点：
  1. 新添加工厂的时候会增加类和接口的个数，增加了系统体量**且一对一的对应方式使得系统体量增速过快**
  2. 引入了新的抽象层，加强了理解难度；运用了反射技术，增加了实现难度

### 产品族的创建——抽象工厂模式

#### 定义

`Abstract Factory Pattern`：提供一个创建一系列或者相互依赖对象的接口，而无须指定它们具体的类。抽象工厂又被称为Kit模式。

#### 目的

在工厂模式中虽然解决了新增产品会违背开闭原则的问题，但是每新增一个产品将会对应多出至少两个类：工厂类和产品类。这样产品一旦多了起来就会使得系统工厂类过于庞大，难以理解和改动。因此我们需要解决这个问题

#### 分析

仔细思考一下，为了解决这种新增产品同时会新增工厂的问题就是让产品和工厂一一对应变成工厂对产品的一对多映射……但是这不得不面对两个问题：

1. 依照什么性质将多种产品放进一个工厂类（也即工厂类根据什么性质分类）
2. 如果要新增加一个产品，不得不修改抽象工厂类的源码，即违背开闭原则

#### 特征

1. 一个工厂不再仅生产一个产品了，而应该根据产品类生产一系列的产品 ----> 抽象工厂中包含多种方法用于生产不用产品
2. 根据某种特征将多种产品封装为一个产品类 ----->需要根据需求设计

#### 简单的实现

现在来考虑一个学科类，它将包含教材和工具两个产品

```java
package abstractFactoryPattern;

/**
 * 产品族抽象工厂类，这里定义多个工厂创建方法
 */
public interface AbstractFactory {
    AbstractSubject createSubject();
    AbstractTools createTools();
}

```

```java
package abstractFactoryPattern;

/**
 * 抽象物品类：科目
 */
public interface AbstractSubject {
    void introduce();
}

```

```java
package abstractFactoryPattern;

/**
 * 抽象物品类：工具
 */
public interface AbstractTools {
    void doSome();
}

```

```java
package abstractFactoryPattern;

/**
 * 语文
 */
public class Chinese implements AbstractSubject{
    @Override
    public void introduce() {
        System.out.println("我是语文");
    }
}
/* -------------------------------产品 ---------------------------------  */
package abstractFactoryPattern;

public class ChineseTools implements AbstractTools {
    @Override
    public void doSome() {
        System.out.println("字典");
    }
}

```

```java
package abstractFactoryPattern;

/**
 * 物理
 */
public class Phy implements AbstractSubject {

    @Override
    public void introduce() {
        System.out.println("我是最好玩的物理");
    }
}
/* -------------------------------产品 ---------------------------------  */
package abstractFactoryPattern;

/**
 * 物理工具
 */
public class PhyTools implements AbstractTools {
    @Override
    public void doSome() {
        System.out.println("仪器");
    }
}

```

```java
package abstractFactoryPattern;

public class ChineseFactory implements AbstractFactory {
    @Override
    public AbstractSubject createSubject() {
        return new Chinese();
    }

    @Override
    public AbstractTools createTools() {
        return new ChineseTools();
    }
}

```

```java
package abstractFactoryPattern;

public class PhyFactory implements AbstractFactory {
    @Override
    public AbstractSubject createSubject() {
        return new Phy();
    }

    @Override
    public AbstractTools createTools() {
        return new PhyTools();
    }
}

```

```java
package abstractFactoryPattern;

public class Client {
    public static void main(String[] args) {
        AbstractFactory factory = new PhyFactory();
        factory.createSubject().introduce();	//  我是最好玩的物理
        factory.createTools().doSome();			//  仪器
    }
}

```

#### 开闭原则的倾斜

在抽象工厂模式中，我们将多种产品按照某性质分类，形成一个个产品类，每个工厂都含有多个创造产品的方法，每个方法都对应一个产品。

- 工厂类与产品类之间是一一到上映射的关系：所以增加产品类会十分便捷，直接加工厂实现抽象工厂就好
- 工厂类和产品之间是一对多的关系：所以要增加一个新的产品的话，我们将不得不修改源代码，在抽象工厂类里面新增一个产品方法

有些时候一对一的工厂方法模式会带来太多的麻烦，这个时候牺牲开闭原则选择抽象工厂也是不错的选择

（？那么原则的意义到底是什么）

#### 优点、缺点

- 优点：
  1. 当一个产品类中的多个对象被设计在一起时，能保证客户用的都是这一类的对象
  2. 增加新的产品族是很简单的
- 缺点：
  1. 新增一个产品的时候，将不得不修改大量的工厂类甚至抽象工厂类，违背开闭原则

#### 使用场景

总的来说，就是将收益最大化，损失最小化：

- 收益最大化：系统有多个产品类，且每次只使用一种产品类
- 收益最大化：同一个产品类的产品将被设计为在一起使用，不会从各种产品类里面选取产品使用
- 损失最小化：产品类的结构稳定，不会轻易地新增或减少产品

### 对象的克隆——原型模式

在对象的创建过程中有些时候会出现初始化会非常耗时的情况（比如数据库的连接）如果按照工厂模式的创建，每一个新的实例都会花费大致相同的时间和资源，而这些实例的差别可能就只是一个参数的区别。为了大幅度优化后面实例的创建，其实只需要将最先创建出来的实例缓存起来，通过克隆再修改一些参数就能够创建对象了。

#### 定义

`Prototype Pattern`:使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。

#### 目的

优化费时费事实例的创建(主要是初始化)

#### 分析

所谓克隆，就是复制+粘贴。因为原型已经进行过初始化，所以单纯的克隆状态并不怎么花费资源和时间。其次原型可以是大有区别的复数实例，这样方便克隆出来的实例简单修改就能覆盖所有实例集。

#### 特征

1. 原型模式需要一个原型===>第一个实例用于克隆，不能是原型模式产生的
2. 同一类的对象====>具有相同的状态类型和改变状态的方法（所有方法都具有这个功能）===>克隆自己就好=====>克隆方法返回自己同状态实例，但是内存地址不一样
3. 具有多个原型====>具有相同的克隆方法====>需要一个抽象原型里面实现克隆的方法（java中就是Object类）

#### 简单的实现

1. 通用实现------与代码无关

   ```java
   // ... 具体原型类实现克隆方法
   public Prototype clone(){
   A a = new A();
   a.setAttr(this.attr);	// 具体原型类的状态
   return a
   }
   
   //....
   
   //... 客户端类
   A a = new A(...Object args);	// a的初始化过程，可能很费事或者费时
   a.set(Object obj);	// b的初始话过程，大部分略过去了
   A b = a.clone();	// b的创建
   ```

   

2. java实现-------使用`Object`的`clone()`方法

```java
package prototype;

import lombok.Data;

/**
 * java中的抽象原型类就是Object
 * 具体原型类，
 */
@Data
public class ConcretePrototype implements Cloneable {
    private String name;
    private int age;

    @Override
    public ConcretePrototype clone() throws CloneNotSupportedException {
        return (ConcretePrototype) super.clone();
    }

    public void printSome() {
        System.out.println("**********" + getName() + "**********");
        System.out.println("**********          **********");
        System.out.println("**********          **********");
        System.out.println("**********" + getAge() + "**********");
    }
}

```

```java
package prototype;

public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        ConcretePrototype prototype = new ConcretePrototype();
        prototype.setAge(18);
        prototype.setName("周报");
        prototype.printSome();
        System.out.println("----------------------------------");
        ConcretePrototype clone = prototype.clone();
        clone.setName("日报");
        clone.setAge(19);
        clone.printSome();
    }
}
/*
**********周报**********
**********          **********
**********          **********
**********18**********
----------------------------------
**********日报**********
**********          **********
**********          **********
**********19**********
*/
```

#### Java实现的注意点

1. 因为clone方法在Object中的方法是protected的，所以在具体原型类中需要将其提升至public，好让client中使用这个方法
2. 只有实现了Cloneable接口的类才能使用clone方法，所以具体原型类中必须要实现这个标志性接口
3. clone只需要调用父级的clone接口就好了

#### 浅拷贝与深拷贝

- 浅拷贝;基本类型进行拷贝，引用类型直接共享一个地址；**Object的clone方法是浅拷贝**
- 深拷贝：基本类型和引用类型都是拷贝，即引用类型的地址不一样；**java提供的序列化可以做到深拷贝**

#### 深拷贝的实现——序列化

这里简单说说序列化：所谓序列化就是将对象转为流（二进制数据）的过程，将对象序列化再反序列化重新生成的对象和原对象状态完全一致但是是深拷贝。

```java
package prototype;
import lombok.Data;
import java.io.*;
/**
 * 具体原型（也是抽象原型）
 */
@Data
public class DeepPrototype implements Serializable {
    private String name;
    private int age;
    private Object obj;

    public DeepPrototype deepClone() throws IOException, ClassNotFoundException {
        ByteArrayOutputStream bao = new ByteArrayOutputStream();    // 输出流
        ObjectOutputStream oos = new ObjectOutputStream(bao);       // 序列化流，写入到上面的输出流里面
        oos.writeObject(this);                                      // 向序列化流里面写入对象
        // 下面是反序列化
        ByteArrayInputStream bai = new ByteArrayInputStream(bao.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bai);
        return (DeepPrototype) ois.readObject();
    }
}
```

```java
package prototype;

import java.io.IOException;

public class DeepClient {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        DeepPrototype prototype = new DeepPrototype();
        prototype.setAge(18);
        prototype.setName("1111");
        prototype.setObj(new Client());	// 注意Client类必须也要实现Serializable接口
        DeepPrototype o = prototype.deepClone();
        System.out.println(o.getObj().equals(prototype.getObj()));	// false 没有实现equals方法
    }
}

```

#### 我自己的另一个实现——抽出了抽象原型类

```java
package prototype;

import java.io.*;
// 抽象原型类
public interface AbstractDeepPrototype extends Serializable {
    default Object deepClone() throws IOException, ClassNotFoundException {
        ByteArrayOutputStream bao = new ByteArrayOutputStream();    // 输出流
        ObjectOutputStream oos = new ObjectOutputStream(bao);       // 序列化流，写入到上面的输出流里面
        oos.writeObject(this);                                      // 向序列化流里面写入对象
        // 下面是反序列化
        ByteArrayInputStream bai = new ByteArrayInputStream(bao.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bai);
        return  ois.readObject();
    }
}

```

```java
package prototype;

import lombok.Data;

import java.io.*;

/**
 * 具体原型
 */
@Data
public class DeepPrototype implements AbstractDeepPrototype {
    private String name;
    private int age;
    private Student student;

    @Override
    public DeepPrototype deepClone() throws IOException, ClassNotFoundException {
        return (DeepPrototype)AbstractDeepPrototype.super.deepClone();
    }
}

```

```java
package prototype;

import java.io.IOException;

public class DeepClient {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        DeepPrototype prototype = new DeepPrototype();
        prototype.setAge(18);
        prototype.setName("1111");
        prototype.setStudent(new Student("胡"));
        DeepPrototype o = prototype.deepClone();
        System.out.println(o);	// DeepPrototype(name=1111, age=18, student=Student(name=胡))
        System.out.println(o.getStudent() == prototype.getStudent()); // false
    }
}

```

感觉上面的更简单……话说接口的interface.super到底是什么

#### 原型管理器的引用和实现

考虑到常用的原型越来越多，整理和管理这些原型的管理器就是有必要的

1. 管理器的状态应该是唯一的——单例模式
2. 管理器应该能保存多种原型——用容器装
3. 管理器应该可以得到各种原型的克隆实例——工厂模式：实例的创建使用clone

```java
package prototypeManager;

/**
 * 抽象原型
 */
public interface AbstractPrototype extends Cloneable {
    AbstractPrototype clone();
    // 业务方法
    void display();
}

```

```java
package prototypeManager;
// 具体原型类 忽略其他原型类和属性
public class DayOfficePattern implements AbstractPrototype {
    @Override
    public AbstractPrototype clone() {
        // 克隆方法
        AbstractPrototype abstractPrototype = null;
        try {
            abstractPrototype = (AbstractPrototype) super.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return abstractPrototype;
    }

    @Override
    public void display() {
        // 这里写业务方法
        System.out.println("日报模板");
    }
}

```

```java
package prototypeManager;

import java.util.HashMap;

/**
 * 原型管理器
 */
public class PrototypeManager {
    private HashMap<String, AbstractPrototype> map = new HashMap();
    private static PrototypeManager prototypeManager = new PrototypeManager();

    private PrototypeManager() {
        map.put("day", new DayOfficePattern());
        map.put("week", new WeekOfficePattern());
    }

    public void addPrototype(String name, AbstractPrototype prototype) {
        map.put(name, prototype);
    }

    public AbstractPrototype getPrototype(String name) {
        // 偷懒没写，可以写个try-catch处理空指针异常
        AbstractPrototype clone = null;
        try {
            clone = map.get(name).clone();
        } catch (Exception e) {
            // log.error("没有这样的模板！")
            e.printStackTrace();
        }
        return clone;
    }

    public static PrototypeManager getManager() {
        return prototypeManager;
    }
}

```

```java
package prototypeManager;

public class Client {
    public static void main(String[] args) {
        PrototypeManager manager = PrototypeManager.getManager();
        AbstractPrototype day = manager.getPrototype("day");
        day.display();	//日报模板
        AbstractPrototype week = manager.getPrototype("week");
        week.display();	//周报模板
        AbstractPrototype day1 = manager.getPrototype("day");
        System.out.println(day == day1);	// false
        System.out.println(day.getClass() == day1.getClass());	// true

        AbstractPrototype year = manager.getPrototype("year");
        System.out.println(year);	// null
    }
}

```

#### 优点、缺点

- 优点：
  1. 大大减少了初始化耗费的时间和性能，非常适合创建多个初始化很复杂的实例
  2. 扩展性很强，仅仅需要修改一些属性就可以称为一个新的原型
  3. 结构等级很简单，和简单工厂类似，仅仅需要一个管理器即可控制多个原型，较简单情况下自己就可以作为工厂
  4. 可以使用深拷贝的方式来保存某一时刻的状态，实现撤销、历史步骤的操作
- 缺点：
  1. 需要为每一个具体原型类配备一个克隆方法，并且这个方法位于类的内部，修改违背了开闭原则
  2. 深拷贝的时候代码较为复杂，并且如果对象的属性是另一个对象，这样的嵌套过多的时候，每一个都需要支持深拷贝，实现起来会非常困难

#### 再论实例的创建

可以看出原型模式和工厂模式有了本质的差别——那便是从第二个实例开始是选择再走一遍构造器的方式呢还是直接复制现有的对象来进行更改呢。

事实上，java中创建实例的方法无非2大类：

- 从构造器创建——new和反射的newInstance均属于此类
- 直接复制对象——clone和反序列化读取readObject便属于此类

也因此，如果实例的初始化比较麻烦的时候，从第二个开始的时候使用复制会有很好的优化效果。

### 复杂对象的组装和创建——建造者模式

之前从对象的创建分出了两种创建方式——工厂模式和原型模式，现在我们将视线投向初始化过程中。

如果一个对象的初始化各个属性含有多个比较复杂的对象，属性是否需要初始化，或者属性之间具有相互依赖需要指定顺序的时候，可以考虑将对象的表示和初始化分离开。定好一套固定的每个复杂对象的构造过程，根据不同的表示在对一个的builder类里面选择性的进行属性初始化与否和顺序。

#### 定义

`Builder Pattern`：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

#### 目的

分离复杂对象的构建过程，使用相同的构建过程来构建不同的产品。

#### 分析

将一个复杂对象的初始化过程分离为另一个类进行这些个复杂部分的初始化，即在另一个builder类里面实现初始化逻辑代码，在director类里面进行生产什么对象和初始化属性

#### 特征

1. 有一个复杂的对象——定义一个Product类，如果有根据产品实现的业务方法，则此类是一个abstract的类
2. 将初始化过程分离开来——需要一个builder类，来控制实现具体那些个属性对应实例的的初始化，并且最后返回这个实例
3. 可能有多种同一类的不同实例（逻辑、顺序不同）——每一个都对应一个builder类，所以抽象出abstractBuilder接口，该接口需要定义两种方法：
   1. ​	初始化各种属性的方法
   2. ​    返回实例对象的方法
4. 最后需要一个和客户沟通，决定调用什么builder，是否构建某个部分——一个director，调用AbstractBuilder的方法

#### 简单实现

```java
package constructPattern;

import lombok.Data;
import lombok.ToString;

/**
 * 产品类
 */
@Data
@ToString
public class Product {
    private String type;
    private String name;
    private String gender;
    private int atk;
    private int def;
}

```

```java
package constructPattern;

/**
 * 抽象builder类，负责定义初始化产品需要的方法：初始化product和返回product
 */
public abstract class AbstractBuilder {
    protected Product product = new Product();

    public abstract void setType();
    public abstract void setName();
    public abstract void setGender();
    public abstract void setAtk();
    public abstract void setDef();

    public Product getInstance(){
        return this.product;
    }
}

```

```java
package constructPattern;

public class LancerBuilder extends AbstractBuilder {
    @Override
    public void setType() {
        product.setType("Lancer");
    }

    @Override
    public void setName() {
        product.setName("KQL");
    }

    @Override
    public void setGender() {
        product.setGender("male");
    }

    @Override
    public void setAtk() {
        product.setAtk(100);
    }

    @Override
    public void setDef() {
        product.setDef(100);
    }
}

```

```java
package constructPattern;

public class Director {
    public Product construct(AbstractBuilder builder) {
        Product product = null;
        builder.setAtk();
        builder.setDef();
        builder.setGender();
        builder.setName();
        builder.setType();
        product = builder.getInstance();
        return product;
    }
}

```

```java
package constructPattern;

public class Client {

    public static void main(String[] args) {
        Director director = new Director();	
        Product product = director.construct(new LancerBuilder());	// Builder可以通过配置修改
        System.out.println(product);
    }
}

```

#### director类的几种变化

- ##### 省略director

  ​	事实上，director和builder的职责是如此之近。前者决定调用哪个builder，并且决定调用逻辑；后者定义了构建逻辑。在一些情况下，完全可以将director的职责封装进builder中。
  ​	这样Builder类就要负责构建出实例，在抽象类中定义construct方法。

  ```java
  // 将director封装进builder中
  // 自己作为参数传给自己肯定可以优化为不传参数直接调，现在将contruct方法设为static的，可以直接根据传入的
  // 参数进行构建
  public abstract class AbstractBuilder {
      protected static Product product = new Product();
  
      public abstract void setType();
      public abstract void setName();
      public abstract void setGender();
      public abstract void setAtk();
      public abstract void setDef();
  
      public static Product construct(AbstractBuilder builder){
          builder.setType();
          builder.setName();
          // ...
          return product;
      }
  }
  // 或者去掉参数
  public abstract class AbstractBuilder {
      protected Product product = new Product();
  
      public abstract void setType();
      public abstract void setName();
      public abstract void setGender();
      public abstract void setAtk();
      public abstract void setDef();
  
      public Product construct(AbstractBuilder builder){
          this.setType();
          this.setName();
          // ...
          return product;
      }
  }
  ```

  ```java
  // 客户端的两种调用方式
  // 第一种方式
  AbstractBuilder ab;
  lb = (LancerBuilder)Utils.getBean("LancerBuilder");
  
  AbstractBuilder.construct(lb);
  // 第二种方式
  AbstractBuilder ab = (LancerBuilder) Utils.getBean("LancerBuilder");
  ab.construct();
  ```

  此时我们简化了建造者模式的结构但是也加重了builder类的职责，如果需要建造的对象确实十分复杂还是建议使用director类进行指导，这样更符合单一职责原则

- 钩子方法

  ​	钩子方法的引入可以使得director更精细地建造对象，钩子函数的返回值一般是boolean类型的，方法名是isXXX()

  它们被定义在抽象builder类中，这样在具体builder中就可以覆盖这个方法在director中根据这个函数返回值来决定是否构建某一个部分或者顺序

  ```java
  // AbstractBuilder
  public abstract boolean isMale();
  // LancerBuilder
  @Override
  public boolean isMale() {
      return true;
  }
  // Director
  if (builder.isMale()) {
      // 男人才有防御
      builder.setDef();
  }
  ```

#### 缺点、优点

1. 优点：
   1. 客户可以不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
   2. 每一个具体builder都相互独立，可以很方便扩展新的产品
   3. 可以在director里面很精细地控制产品创建地过程
2. 缺点：
   1. 该模式创建地产品必须有较多的共性，组成部分相似，不然不适用
   2. 如果组成产品地内部结构复杂且多变，那么需要大量地具体builder类，增加系统体量和理解难度

#### 适用场景

- 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量
- **需要生成的产品对象属性之间相互依赖，需要指定生成顺序**
- **对象的创建过程独立于创建该对象的类。在建造者模式中通过引入director类将创建过程封装在director类中，而不在建造者类或者客户类中**
- 隔离复杂对象的创建和引用，并使得相同的创建过程可以创建不同的产品

## 五、结构型模式

在oop中，不同的类/对象都具有一定的结构，这些结构决定了它们的职责，而它们的相互协作可以完成复杂的功能。结构型模式（Structural Pattern）关注如何将现有的类和对象组织在一起形成更为强大的结构。

**一般来说，有对象结构模式和类结构模式两种：**

- 类结构模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构模型中一般是继承和实现关系
- 对象结构模式：关心类与对象的组合，一般是在一个类中使用一个类的实例对象，用该对象调用方法。

因为Java不支持多继承，所以一般以对象结构模式为主

### 不兼容结构的协调——适配器模式

#### 定义

`Adapter Pattern`:将一个接口转换成客户希望的另一个接口，使接口不相容的那些类可以一起工作，别名包装器(Wrapper)。

#### 目的

在开发软件的过程中不可避免地会遇到使用第三方或者丢失了源码的包，如果Client端面向的接口与该第三方包的接口不兼容，且两方都不好修改的情况下，可以考虑时候一个适配器来使得2者兼容。

**也就是说解决的问题目的是:不改动源码的情况下，让两个本无关系的类，其中一个类的方法可以达到另一个类的某个方法的效果**

#### 分析与特征

**如果存在两个类A,B，它们之间没有任何关系，现在想在A中调用a方法实现和B中b方法一样的效果，且二者的代码不便改动的时候，就可以使用适配器模式：适配器C继承A，关联B，重写A的a方法，a中调用B对象的b方法即可（对象适配器，也是委派关系）**

#### 简单实现

-----------------------------------------对象适配器模式-------------------------------------------------

```java
package adapterParrten;
public class Client {
    public static void main(String[] args) {
        Target t = new Adapter();
        t.saySomething();
        System.out.println(t.add());
    }
}
// console 如下所示
/*
本来是写下来的东西，现在是说出来的
错了
0
*/
```

```java
package adapterParrten;
/**
 * 暴露给客户端的接口，声明了客户端需要的方法
 * 如果是类的话适配器继承，如果是接口的话适配器实现
 * 如果全部都是接口的话，适配器可以多实现完成类适配器模式
 */
public interface Target {
    void saySomething();
    int add();
}

```

```java
package adapterParrten;

/**
 * 适配者类，被适配器包裹提供方法
 */
public class Adaptee {
    public void writeSomething(){
        System.out.println("本来是写下来的东西，现在是说出来的");
    }

    public int wrongTake(){
        System.out.println("错了");
        return 0;
    }

    public void noUse(){
        System.out.println("不会用的方法");
    }
}

```

```java
package adapterParrten;

/**
 * 适配器，用来兼容两个本无关系的类
 */
public class Adapter implements Target {
    private Adaptee adaptee;   // 表示包裹这个适配者

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public Adapter() {
        // 默认包裹这个adaptee
        this.adaptee = new Adaptee();
    }

    @Override
    public void saySomething() {
        adaptee.writeSomething();
    }

    @Override
    public int add() {
        return adaptee.wrongTake();
    }
}

```

-----------------------------------------对象适配器模式-------------------------------------------------

-------------------------------------------类适配器模式--------------------------------------------------

因为java并不支持多继承，所以类适配器模式需要以多实现的方式来完成，但是这又会出现很多限制，所以java中一般不会使用类适配器模式、至于如何使用，应该很好想，这里略过

-------------------------------------------类适配器模式--------------------------------------------------

#### 双向适配器模式

注意到适配器实现了Target接口，组合了Adaptee对象，将Target的方法委托给Adaptee对象。而实现、组合都是可以多重的，所以适配器完全可以**同时**实现Adaptee接口，组合Target对象，将Adptee方法委托给Target对象，如此便实现了一个双向适配器，在Target调用Adaptee的方法，在Adaptee调用Target的方法。

```java
public class A implements B,C{
    private B b;
    private C c;
    
    public A (B b){
        this.b = b;
    }
    public A (C c){
        this.c = c;
    }
    public void doSome(){
        b.doSome(); // C调用
    }
    public void writeSome(){
        c.doSome(); // B调用
    }
}
```



#### 缺省适配器模式

注意到如果Target包含大量为实现的方法的话，适配器需要实现里面的所有方法，而这些方法里面的部分方法可能是不需要实现的，因此为了方便适配器的编写，可以引入缺省适配器类先给所有方法一个空实现，真正的具体适配器类再继承它，重写需要实现的方法。

#### 优点、缺点

- 优点：

  1. 将Target和Adaptee类解耦，通过引入一个Adapter类来重现现有Adaptee类，无需修改原结构

     ===========================类适配器模式=================================

  2. 在必要的情况下可以使用适配器重写一些被适配者的方法来实现一些业务

     ===========================对象适配器模式=================================

  2. 一个适配器可以组合多个多个被适配者
  3. 被适配者的子类也可以直接在适配器中使用（里氏代换原则）

- 缺点：
  1. 类适配器模式在java的最大问题就是不能多继承、其次被适配者类不能是final的
  2. 对象适配器模式与类适配器模式相比，想在适配器中置换被适配者类的某些方法比较麻烦。需要新作一个被适配者的子类，（重写方法后）将子类放入适配器中

### 处理多维度变化——桥接模式

#### 定义

`Bridge Pattern`：将抽象部分与其实现部分分离，使他们都可以独立地变化。又称柄体模式或接口模式

#### 目的

分离某个类中耦合的两个操作无关变量（即2维），所谓操作无关指的是在自然、业务关系中两变量不存在任何限制或边界条件。

#### 分析

如果一个类A存在两个维度，那么一定存在一种操作无关的组合结构即——桥接模式。

两个维度分别构建自己的抽象表示——接口或者抽象类，然后对这两个维度进行实现，因为这两个维度要关联起来，所以需要其中一个是**抽象类**，并且组合另一个接口，这就完成了桥接。

#### 特征

1. 多个操作无关的变量：桥接模式一定只适用于可以分离（解耦）的多个变量
2. 多个变量地位等价：因为多个变量之间无关，所以地位等价，都需要一个抽象表示
3. 有一个变量身份不同：虽然地位等价，但是需要一个变量将其他变量组合起来，习惯上是与业务最紧密的那个变量作为抽象类，进行组合。
4. 针对各个抽象表示编程。

#### 简单实现

```java
package bridgePattern;

/**
 * 抽象类，组合其他类并且声明业务方法
 */
public abstract class Abstraction {
    protected Implementor implementor;    // 组合抽象实现类

    public void setImplementor(Implementor implementor) {
        this.implementor = implementor;     // setter注入
    }

    public abstract void doOther();     // 业务方法声明
}

```

```java
package bridgePattern;

/**
 * 实现类接口，声名基本操作即可，业务操作在抽象类中进行
 */
public interface Implementor {
    void doSome();
}

```

```java
package bridgePattern;

/**
 * 具体类，偷懒只写一个了
 */
public class RefineAbstraction extends Abstraction {
    @Override
    public void doOther() {
        implementor.doSome();
    }
    // 其他业务方法
}

```

```java
package bridgePattern;

/**
 * 具体实现类一
 */
public class ConImplOne implements Implementor {
    @Override
    public void doSome() {
        System.out.println("我是具体实现类1");
    }
}

```

```java
package bridgePattern;

/**
 * 具体实现类二
 */
public class ConImplTwo implements Implementor {
    @Override
    public void doSome() {
        System.out.println("我是具体实现类2");
    }
}

```

```java
package bridgePattern;

public class Client {
    public static void main(String[] args) {
        Abstraction abstraction = new RefineAbstraction();
        Implementor implementor = new ConImplOne();

        abstraction.setImplementor(implementor);

        abstraction.doOther(); 			// 我是具体实现类1
    }
}

```

#### 桥接模式和适配器模式的联合使用

在软件开发中，桥接模式和适配器模式经常一起使用，在设计软件的时候，将解耦出的桥接模式里发现某个具体实现类需要使用到不兼容的第三方类，此时就可以在这里使用适配器模式。

#### 优点、缺点

- 优点：桥接模式解耦了抽象和实现的固有绑定关系，打破了多层次继承的编程模式
- 缺点：要求在一开始就在抽象层建立关联关系，所以一开始就得对抽象层编程

### 树形结构的处理——组合模式

#### 定义

